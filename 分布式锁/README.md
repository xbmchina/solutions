![](https://upload-images.jianshu.io/upload_images/13150128-9b0d63764cc40a7f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 前言
在分布式系统中，分布式锁是为了解决多实例之间的同步问题。例如master选举，能够获取分布式锁的就是master，获取失败的就是slave。又或者能够获取锁的实例能够完成特定的操作。

目前比较常用的分布式锁实现有两种，基于zookeeper实现和基于redis实现。zookeeper和redis也是生产环境中经常用到的第三方组件。下面我会分析它们的实现原理。

### 实现要求

实现一个分布式锁至少要满足下面三点要求：
1）互斥，在任何时候同一个锁只能由一个客户端持有。
2）不会死锁，就算持有的客户端异常崩溃也不会影响后续客户端加锁。
3）谁加锁谁解锁，加锁和解锁都必须是同一个客户端。


### 1.基于数据库实现分布式锁
基于数据库表
要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。

创建这样一张数据库表：
```sql
CREATE TABLE `methodLock` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `method_name` varchar(64) NOT NULL DEFAULT '' COMMENT '锁定的方法名',
  `desc` varchar(1024) NOT NULL DEFAULT '备注信息',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '保存数据时间，自动生成',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uidx_method_name` (`method_name `) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';
```

当我们想要锁住某个方法时，执行以下SQL：

```sql
insert into methodLock(method_name,desc) values (‘method_name’,‘desc’)
```
因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。

当方法执行完毕之后，想要释放锁的话，需要执行以下Sql:

```sql
delete from methodLock where method_name ='method_name'
```

上面这种简单的实现有以下**几个问题：**
>1、这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。
2、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。
3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。
4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。

当然，我们也可以有其他方式解决上面的问题。
>1、数据库是单点？
搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。
2、没有失效时间？
只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。
3、非阻塞的？
搞一个while循环，直到insert成功再返回成功。
4、非重入的？
在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。

#### 小结
使用数据库来实现分布式锁的方式，这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在；另外一种是通过数据库的排他锁来实现分布式锁（自己可以去琢磨一下）。

数据库实现分布式锁的优点
1）直接借助数据库，容易理解。

数据库实现分布式锁的缺点
1）会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。
2）操作数据库需要一定的开销，性能问题需要考虑。
3）使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。


### 2.基于zookeeper实现分布式锁
在讲解zookeeper的分布式锁之前有两个概念需要明确：
* **临时节点**：生命周期和链接周期一致。例如客户端链接A创建了临时节点NodeA，如果链接A关闭或者网络异常断开，那么NodeA也会跟着消失。

* **顺序节点**：节点名称按照顺序从小到大创建，例如先创建了000000001，那么接着创建的节点就会分配000000002。

zookeeper的分布式锁实现原理就是利用**临时顺序节点**，大概流程为：
1）每个客户端对某个功能加锁时，在zookeeper指定目录下生成一个唯一的临时顺序节点。
2）所有临时节点中序号最小的节点即为当前锁的持有者。
3）释放锁时将自己持有的临时节点删除即可。

例如，对于加锁过程，所有的客户端都在/lock目录下面创建临时节点，如果发现自己创建的临时节点是/lock目录中最小的节点，那么就获取锁成功，否则就watch比自己小的节点中的最大节点。

**监控比自己小的节点中的最大节点是为了避免“惊群”效应，避免一个锁释放把所有等待的客户端唤醒，但是只有一个客户端能获取锁。**

对于释放锁，只需要把自己创建的临时顺序节点删除即可。整个过程流程图如下：

![](https://upload-images.jianshu.io/upload_images/13150128-404fc3b09e75d64d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

优点：锁安全性高，zookeeper数据不易丢失。用户使用简单。

缺点：性能消耗比较高。因为需要动态产生和删除临时节点，当集群负载比较高时临时节点消失会有时间差（一般在一分钟范围内）。


### 3.redis分布式锁

redis的分布式锁实现比zookeeper分布式锁实现复杂，也分为redis单实例和多实例（master-master）实现方式。

需要特别指出的是redis如果是master-slave这种结构部署时，获取和释放锁都只能向master请求，和单实例的实现原理基本一样，否则主从切换时会出现多人拿到同一把锁的情况。
例如：
1）客户端A在master拿到了锁。
2）master节点在把A创建的key写入slave之前宕机了。（主从同步是异步操作）
3）slave变成了master节点。
4）B也得到了和A还持有的相同的锁，因为slave还没有A持有锁的信息。

#### redis单实例实现方案

通过下面命令获得锁：
```bash
SET resource_name my_random_value NX PX 30000
```
这个命令的作用是只有这个key不存在时才会设置这个key的值（NX的作用，即not exist），超时时间设置为30000毫秒（PX的作用），这个key的值设置为my_random_value。这个值必须在所有获取锁请求的客户端里面保持唯一。

key值的超时时间，也叫做“锁有效时间”。这是锁的自动释放时间。

这套实现方案在非分布式的、单点的、保证永不宕机的环境是适用的。


#### redis集群实现方案（Redlock算法）
在分布式版本的算法里我们假设有N个redis master节点，这些节点完全独立，不用任何的复制或者分布式协调算法来同步数据。

这里假设N=5，一个客户端获取锁的过程如下：

1）获取当前以毫秒为单位的时间。
2）轮询用相同的key在N个节点上面请求锁。（每个请求的超时时间设置的短一些，为了一个master节点不用时，快速请求下一个master）。
3）如果在超过一半master节点上面成功获取锁（这里是3个），客户端计算第二步请求锁花费的时间，如果小于锁释放时间，则认为获取锁成功。
4）如果锁获取成功了，那么现在 锁自动释放时间=最初锁释放时间-请求锁花费的时间
5）如果获取锁失败了（成功的锁不超过master数量的一般 或者 请求耗时>锁释放时间），那么客户端都会在每个master节点上面释放锁。

获取锁成功的节点数需要超过master节点数量的一半才认为是获取锁成功的思路应该是借鉴了zookeeper的paxos算法。

还有一个需要指出的点是，当一个客户端获取失败时应该随时延时后再进行重试，避免多个客户端同时重试又同时失败。

优点：性能高

缺点：单实例会有单点问题，多实例主从切换会导致数据丢失，master-master集群模式实现复杂。


参考文章：

[https://www.cnblogs.com/makelu/p/11010781.html](https://www.cnblogs.com/makelu/p/11010781.html)

[http://www.hollischuang.com/archives/1716](http://www.hollischuang.com/archives/1716)


![](https://upload-images.jianshu.io/upload_images/13150128-132fe0843e27a172.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)